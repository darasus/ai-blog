{
  "category": "coding",
  "imageSrc": "https://theaipaper.b-cdn.net/articles/java-performance-tuning.png",
  "imageSrcBase64": "data:image/png;base64,UklGRlwAAABXRUJQVlA4IFAAAAAQAgCdASoKAAoAAUAmJZwC7AEQ/c9pFGYAAP7+Ld91k4CuTWLekqwAee8v9Jz16HjQngQDcCNwgw6K/2AMPsYKLLSo6txnXk076MriagAAAA==",
  "createdAt": "2022-10-01T11:15:08.366Z",
  "updatedAt": "2022-10-01T11:15:08.366Z",
  "slug": "ajuste-del-rendimiento-de-java",
  "locale": "es",
  "categoryLocal": "codificación",
  "title": "Ajuste del rendimiento de Java",
  "summary": "Debe medir el rendimiento de su aplicación antes de ajustar la JVM. Lo primero que discutiremos cuando se trata de ajustes es el tamaño del almacenamiento dinámico. El almacenamiento en caché del código de bytes para toda su aplicación puede causar problemas si es necesario compilar dos o más clases diferentes al mismo tiempo. Agregar código de ruta rápida a su código Java puede ayudar a mejorar el rendimiento al eliminar la sobrecarga de crear un nuevo hilo para cada llamada que se crea. Use el código API'path en el código Java que se usará con frecuencia, y otros solo se usarán ocasionalmente.",
  "intro": {
    "compiledSource": "var l=Object.defineProperty,m=Object.defineProperties;var p=Object.getOwnPropertyDescriptors;var s=Object.getOwnPropertySymbols;var t=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var c=(e,a,o)=>a in e?l(e,a,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[a]=o,i=(e,a)=>{for(var o in a||(a={}))t.call(a,o)&&c(e,o,a[o]);if(s)for(var o of s(a))r.call(a,o)&&c(e,o,a[o]);return e},u=(e,a)=>m(e,p(a));var d=(e,a)=>{var o={};for(var n in e)t.call(e,n)&&a.indexOf(n)<0&&(o[n]=e[n]);if(e!=null&&s)for(var n of s(e))a.indexOf(n)<0&&r.call(e,n)&&(o[n]=e[n]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var n=o,{components:e}=n,a=d(n,[\"components\"]);return mdx(MDXLayout,u(i(i({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`En el primer art\\xEDculo de esta serie, discutimos c\\xF3mo el ajuste del rendimiento de Java puede ser complicado. Los diferentes factores que afectan el rendimiento y c\\xF3mo puede medirlos. En este art\\xEDculo, repasaremos las estrategias espec\\xEDficas para ajustar sus aplicaciones Java para obtener un mejor rendimiento. Hay muchas partes m\\xF3viles en una m\\xE1quina virtual Java y una variedad de cosas que pueden afectar negativamente el rendimiento.\nDiscutiremos algunas t\\xE9cnicas y configuraciones espec\\xEDficas que puede usar para ajustar su JVM para mejorar el rendimiento. Esto incluye el tama\\xF1o del mont\\xF3n, el almacenamiento en cach\\xE9 del c\\xF3digo, las opciones del compilador, el uso del c\\xF3digo y el modo de interpretaci\\xF3n. Siga leyendo para obtener m\\xE1s informaci\\xF3n sobre estos conceptos y sus implicaciones en el rendimiento de su aplicaci\\xF3n.`))}MDXContent.isMDXComponent=!0;\n",
    "scope": {}
  },
  "content": {
    "compiledSource": "var u=Object.defineProperty,m=Object.defineProperties;var p=Object.getOwnPropertyDescriptors;var i=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable;var d=(e,a,o)=>a in e?u(e,a,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[a]=o,s=(e,a)=>{for(var o in a||(a={}))r.call(a,o)&&d(e,o,a[o]);if(i)for(var o of i(a))c.call(a,o)&&d(e,o,a[o]);return e},l=(e,a)=>m(e,p(a));var t=(e,a)=>{var o={};for(var n in e)r.call(e,n)&&a.indexOf(n)<0&&(o[n]=e[n]);if(e!=null&&i)for(var n of i(e))a.indexOf(n)<0&&c.call(e,n)&&(o[n]=e[n]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var n=o,{components:e}=n,a=t(n,[\"components\"]);return mdx(MDXLayout,l(s(s({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"h2\",null,\"Mide antes de afinar\"),mdx(\"p\",null,\"Antes de sumergirse en el ajuste, debe asegurarse de haberse tomado el tiempo para medir el rendimiento de su aplicaci\\xF3n. Este es especialmente el caso si tiene problemas de rendimiento. No desea comenzar a realizar cambios en su JVM que podr\\xEDan afectar negativamente el rendimiento de su aplicaci\\xF3n y luego no saber qu\\xE9 lo caus\\xF3. Tomarse el tiempo para establecer una l\\xEDnea de base lo ayudar\\xE1 a identificar cambios y sacar conclusiones sobre qu\\xE9 marc\\xF3 la diferencia.\"),mdx(\"p\",null,\"Puede usar una variedad de herramientas para medir el rendimiento de su aplicaci\\xF3n. Puede utilizar los generadores de perfiles integrados que se incluyen con su JVM. Tambi\\xE9n hay una serie de herramientas de c\\xF3digo abierto que pueden ayudarlo a medir su rendimiento y proporcionar informaci\\xF3n sobre los cuellos de botella.\"),mdx(\"h2\",null,\"Tama\\xF1o del almacenamiento din\\xE1mico de JVM y rendimiento de la plataforma\"),mdx(\"p\",null,\"Lo primero que discutiremos cuando se trata de ajustar la JVM es el tama\\xF1o del mont\\xF3n. El mont\\xF3n es el espacio que utiliza la JVM para almacenar objetos. A medida que su programa se ejecuta, crear\\xE1 nuevos objetos y liberar\\xE1 los antiguos. Estos objetos se almacenan en el mont\\xF3n. La JVM es responsable de decidir cu\\xE1ndo crear nuevos montones y qu\\xE9 tan grandes hacerlos.\"),mdx(\"p\",null,\"La mayor\\xEDa de las veces, este proceso funciona bien. Pero si el tama\\xF1o de su almacenamiento din\\xE1mico es demasiado peque\\xF1o o su sistema est\\xE1 bajo una gran carga, la JVM no puede seguir el ritmo y el rendimiento se ver\\xE1 afectado. Cuando su aplicaci\\xF3n est\\xE1 experimentando un bajo rendimiento y nota que la JVM est\\xE1 usando mucho tiempo de procesador y tarda mucho tiempo en completar las tareas, puede ser \\xFAtil aumentar el tama\\xF1o de almacenamiento din\\xE1mico.\"),mdx(\"h2\",null,\"Almacenamiento en cach\\xE9 de c\\xF3digo\"),mdx(\"p\",null,\"Uno de los primeros pasos en el ajuste del rendimiento de Java es observar c\\xF3mo usa el almacenamiento en cach\\xE9 de c\\xF3digo. El almacenamiento en cach\\xE9 de c\\xF3digo es cuando almacena en cach\\xE9 secciones de c\\xF3digo y no las vuelve a compilar cada vez que se necesitan. Esto generalmente es algo bueno, pero puede causar problemas con su aplicaci\\xF3n si no tiene cuidado. El almacenamiento en cach\\xE9 de c\\xF3digo tambi\\xE9n se puede denominar almacenamiento en cach\\xE9 de bytecode. Es importante tener en cuenta que el almacenamiento en cach\\xE9 de c\\xF3digo no es espec\\xEDfico de la JVM. Es una pr\\xE1ctica com\\xFAn utilizada en todos los lenguajes de programaci\\xF3n. Cuando compila su aplicaci\\xF3n, puede cargar el c\\xF3digo de bytes en su JVM y luego almacenarlo en cach\\xE9. Esto significa que la pr\\xF3xima vez que se ejecute ese c\\xF3digo en particular, el c\\xF3digo de bytes ya estar\\xE1 cargado y no tendr\\xE1 que volver a compilarse. Esto ahorra mucho tiempo al ejecutar su aplicaci\\xF3n.\"),mdx(\"p\",null,\"Pero hay formas de almacenar el c\\xF3digo en cach\\xE9 que pueden causar problemas. Un error com\\xFAn es almacenar en cach\\xE9 el c\\xF3digo de bytes de toda la aplicaci\\xF3n. El almacenamiento en cach\\xE9 del c\\xF3digo de bytes para toda su aplicaci\\xF3n puede causar problemas si es necesario compilar dos o m\\xE1s clases diferentes al mismo tiempo. Esto se debe a que solo se puede usar un compilador a la vez. Si se est\\xE1 compilando otra clase, el c\\xF3digo de bytes del resto de la aplicaci\\xF3n se almacena en cach\\xE9 y no est\\xE1 disponible para las otras clases. Si almacena en cach\\xE9 el c\\xF3digo de bytes para toda su aplicaci\\xF3n, puede causar problemas de rendimiento y dificultar la depuraci\\xF3n.\"),mdx(\"h2\",null,\"Opciones del compilador de Java\"),mdx(\"p\",null,\"Cuando est\\xE1 escribiendo c\\xF3digo Java, hay opciones de compilador que puede usar para cambiar la forma en que se compila su c\\xF3digo. Estas opciones del compilador pueden variar de una plataforma a otra y de un compilador a otro. Pero pueden tener un gran impacto en el rendimiento de su aplicaci\\xF3n Java. Hay dos opciones de compilador que tienen un impacto significativo en el rendimiento. Estas son las opciones -Xss y -Xmx. -Xss: esta opci\\xF3n controla la cantidad de memoria asignada a la pila de seguridad de subprocesos. La pila de seguridad de subprocesos se usa durante la ejecuci\\xF3n de subprocesos para garantizar que las interacciones de subprocesos sean seguras y no causen problemas para otros subprocesos en la JVM. Si establece el valor de esta opci\\xF3n en un valor demasiado bajo, es posible que tenga problemas con la JVM que genera excepciones de falta de memoria. Si lo establece demasiado alto, puede aumentar la sobrecarga de su JVM.\"),mdx(\"p\",null,\"-Xmx: esta opci\\xF3n controla la cantidad de memoria que puede usar la JVM. Si establece este valor demasiado bajo, tendr\\xE1 problemas con la JVM que genera excepciones de memoria. Si lo establece demasiado alto, aumentar\\xE1 la sobrecarga de su JVM.\"),mdx(\"h2\",null,\"Usar API con c\\xF3digo de v\\xEDa r\\xE1pida en ellas\"),mdx(\"p\",null,`Hay partes de su c\\xF3digo Java que se usar\\xE1n con frecuencia, y hay otras que solo se usar\\xE1n ocasionalmente. Si tiene una llamada API que se usa con frecuencia, puede acelerarla agregando un c\\xF3digo de ruta r\\xE1pida.\nSi est\\xE1 utilizando una API de Java y est\\xE1 creando un nuevo hilo para cada llamada, no est\\xE1 utilizando un c\\xF3digo de ruta r\\xE1pida y puede tener un impacto negativo en el rendimiento de su aplicaci\\xF3n. Agregar c\\xF3digo de ruta r\\xE1pida a estas llamadas API puede ayudar a mejorar el rendimiento al eliminar la sobrecarga de crear un nuevo hilo para cada llamada. Puede agregar c\\xF3digo de acceso r\\xE1pido mediante las herramientas de generaci\\xF3n de c\\xF3digo Java o mediante una API espec\\xEDfica de la plataforma.`),mdx(\"h2\",null,\"Use el modo de int\\xE9rprete para comprobar si hay cuellos de botella\"),mdx(\"p\",null,`El modo de int\\xE9rprete es una caracter\\xEDstica \\xFAtil de la JVM que puede usar para verificar cuellos de botella comunes. Para usar el modo de int\\xE9rprete, puede agregar el indicador \"-Xinterpreter\" a su JVM. Cuando usa el modo de int\\xE9rprete, la JVM no traduce su c\\xF3digo de bytes a lenguaje de m\\xE1quina. Mantiene su aplicaci\\xF3n en el lenguaje Java y, en su lugar, utiliza un solo hilo para ejecutar su aplicaci\\xF3n. Esto le permite ver si hay cuellos de botella en su aplicaci\\xF3n causados por la propia JVM.\nEl modo de int\\xE9rprete tambi\\xE9n puede ayudar a identificar llamadas API lentas y cualquier problema con el almacenamiento en cach\\xE9 del c\\xF3digo.`),mdx(\"h2\",null,\"Conclusi\\xF3n\"),mdx(\"p\",null,`En el primer art\\xEDculo de esta serie, discutimos c\\xF3mo el ajuste del rendimiento de Java puede ser complicado. Los diferentes factores que afectan el rendimiento y c\\xF3mo puede medirlos. En este art\\xEDculo, repasaremos las estrategias espec\\xEDficas para ajustar sus aplicaciones Java para obtener un mejor rendimiento. Hay muchas partes m\\xF3viles en una m\\xE1quina virtual Java y una variedad de cosas que pueden afectar negativamente el rendimiento.\nDiscutiremos algunas t\\xE9cnicas y configuraciones espec\\xEDficas que puede usar para ajustar su JVM para mejorar el rendimiento. Esto incluye el tama\\xF1o del mont\\xF3n, el almacenamiento en cach\\xE9 del c\\xF3digo, las opciones del compilador, el uso del c\\xF3digo y el modo de interpretaci\\xF3n. Siga leyendo para obtener m\\xE1s informaci\\xF3n sobre estos conceptos y sus implicaciones en el rendimiento de su aplicaci\\xF3n.\nAhora que est\\xE1 m\\xE1s familiarizado con estos conceptos, puede usarlos para optimizar mejor sus aplicaciones Java y mejorar su rendimiento.`))}MDXContent.isMDXComponent=!0;\n",
    "scope": {}
  }
}